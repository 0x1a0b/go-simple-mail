
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/xhit/go-simple-mail/auth.go (75.0%)</option>
				
				<option value="file1">github.com/xhit/go-simple-mail/email.go (67.9%)</option>
				
				<option value="file2">github.com/xhit/go-simple-mail/message.go (98.8%)</option>
				
				<option value="file3">github.com/xhit/go-simple-mail/smtp.go (69.8%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in https://raw.githubusercontent.com/golang/go/master/LICENSE

package mail

import (
        "errors"
)

// Auth is implemented by an SMTP authentication mechanism.
type Auth interface {
        // Start begins an authentication with a server.
        // It returns the name of the authentication protocol
        // and optionally data to include in the initial AUTH message
        // sent to the server. It can return proto == "" to indicate
        // that the authentication should be skipped.
        // If it returns a non-nil error, the SMTP client aborts
        // the authentication attempt and closes the connection.
        Start(server *ServerInfo) (proto string, toServer []byte, err error)

        // Next continues the authentication. The server has just sent
        // the fromServer data. If more is true, the server expects a
        // response, which Next should return as toServer; otherwise
        // Next should return toServer == nil.
        // If Next returns a non-nil error, the SMTP client aborts
        // the authentication attempt and closes the connection.
        Next(fromServer []byte, more bool) (toServer []byte, err error)
}

// ServerInfo records information about an SMTP server.
type ServerInfo struct {
        Name string   // SMTP server name
        TLS  bool     // using TLS, with valid certificate for Name
        Auth []string // advertised authentication mechanisms
}

type plainAuth struct {
        identity, username, password string
        host                         string
}

// PlainAuth returns an Auth that implements the PLAIN authentication
// mechanism as defined in RFC 4616. The returned Auth uses the given
// username and password to authenticate to host and act as identity.
// Usually identity should be the empty string, to act as username.
//
// PlainAuth will only send the credentials if the connection is using TLS
// or is connected to localhost. Otherwise authentication will fail with an
// error, without sending the credentials.
func PlainAuth(identity, username, password, host string) Auth <span class="cov8" title="1">{
        return &amp;plainAuth{identity, username, password, host}
}</span>

func (a *plainAuth) Start(server *ServerInfo) (string, []byte, error) <span class="cov8" title="1">{
        // Must have TLS, or else localhost server. Unencrypted connection is permitted here too but is not recommended
        // Note: If TLS is not true, then we can't trust ANYTHING in ServerInfo.
        // In particular, it doesn't matter if the server advertises PLAIN auth.
        // That might just be the attacker saying
        // "it's ok, you can trust me with your password."
        if server.Name != a.host </span><span class="cov0" title="0">{
                return "", nil, errors.New("wrong host name")
        }</span>
        <span class="cov8" title="1">resp := []byte(a.identity + "\x00" + a.username + "\x00" + a.password)
        return "PLAIN", resp, nil</span>
}

func (a *plainAuth) Next(fromServer []byte, more bool) ([]byte, error) <span class="cov8" title="1">{
        if more </span><span class="cov0" title="0">{
                // We've already sent everything.
                return nil, errors.New("unexpected server challenge")
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package mail

import (
        "bytes"
        "crypto/tls"
        "encoding/base64"
        "errors"
        "fmt"
        "io/ioutil"
        "mime"
        "net"
        "net/mail"
        "net/textproto"
        "path/filepath"
        "time"
)

// Email represents an email message.
type Email struct {
        from        string
        sender      string
        replyTo     string
        returnPath  string
        recipients  []string
        headers     textproto.MIMEHeader
        parts       []part
        attachments []*file
        inlines     []*file
        Charset     string
        Encoding    encoding
        Error       error
        SMTPServer  *Client
}

//SMTPServer represents a SMTP Server
type SMTPServer struct {
        // From           string
        Encryption     encryption
        Username       string
        Password       string
        ConnectTimeout time.Duration
        SendTimeout    time.Duration
        Host           string
        Port           int
        KeepAlive      bool
}

//SMTPClient represents a SMTP Client for send email
type SMTPClient struct {
        Client      *Client
        KeepAlive   bool
        SendTimeout time.Duration
}

// part represents the different content parts of an email body.
type part struct {
        contentType string
        body        *bytes.Buffer
}

// file represents the files that can be added to the email message.
type file struct {
        filename string
        mimeType string
        data     []byte
}

type encryption int

const (
        // EncryptionTLS sets encryption type to TLS when sending email
        EncryptionTLS encryption = iota
        // EncryptionSSL sets encryption type to SSL when sending email
        EncryptionSSL
        // EncryptionNone uses no encryption when sending email
        EncryptionNone
)

var encryptionTypes = [...]string{"TLS", "SSL", "None"}

func (encryption encryption) String() string <span class="cov0" title="0">{
        return encryptionTypes[encryption]
}</span>

type encoding int

const (
        // EncodingQuotedPrintable sets the message body encoding to quoted-printable
        EncodingQuotedPrintable encoding = iota
        // EncodingBase64 sets the message body encoding to base64
        EncodingBase64
        // EncodingNone turns off encoding on the message body
        EncodingNone
)

var encodingTypes = [...]string{"quoted-printable", "base64", "binary"}

func (encoding encoding) String() string <span class="cov8" title="1">{
        return encodingTypes[encoding]
}</span>

// NewMSG creates a new email. It uses UTF-8 by default.
func NewMSG() *Email <span class="cov8" title="1">{
        email := &amp;Email{
                headers:  make(textproto.MIMEHeader),
                Charset:  "UTF-8",
                Encoding: EncodingQuotedPrintable,
        }

        email.AddHeader("MIME-Version", "1.0")

        return email
}</span>

//NewSMTPClient returns the client for send email
func NewSMTPClient() *SMTPServer <span class="cov8" title="1">{
        server := &amp;SMTPServer{
                Encryption:     EncryptionNone,
                ConnectTimeout: 10 * time.Second,
                SendTimeout:    10 * time.Second,
        }
        return server
}</span>

// GetError returns the first email error encountered
func (email *Email) GetError() error <span class="cov8" title="1">{
        return email.Error
}</span>

// SetFrom sets the From address.
func (email *Email) SetFrom(address string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("From", address)

        return email</span>
}

// SetSender sets the Sender address.
func (email *Email) SetSender(address string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("Sender", address)

        return email</span>
}

// SetReplyTo sets the Reply-To address.
func (email *Email) SetReplyTo(address string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("Reply-To", address)

        return email</span>
}

// SetReturnPath sets the Return-Path address. This is most often used
// to send bounced emails to a different email address.
func (email *Email) SetReturnPath(address string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("Return-Path", address)

        return email</span>
}

// AddTo adds a To address. You can provide multiple
// addresses at the same time.
func (email *Email) AddTo(addresses ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("To", addresses...)

        return email</span>
}

// AddCc adds a Cc address. You can provide multiple
// addresses at the same time.
func (email *Email) AddCc(addresses ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("Cc", addresses...)

        return email</span>
}

// AddBcc adds a Bcc address. You can provide multiple
// addresses at the same time.
func (email *Email) AddBcc(addresses ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddAddresses("Bcc", addresses...)

        return email</span>
}

// AddAddresses allows you to add addresses to the specified address header.
func (email *Email) AddAddresses(header string, addresses ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">found := false

        // check for a valid address header
        for _, h := range []string{"To", "Cc", "Bcc", "From", "Sender", "Reply-To", "Return-Path"} </span><span class="cov8" title="1">{
                if header == h </span><span class="cov8" title="1">{
                        found = true
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                email.Error = errors.New("Mail Error: Invalid address header; Header: [" + header + "]")
                return email
        }</span>

        // check to see if the addresses are valid
        <span class="cov8" title="1">for i := range addresses </span><span class="cov8" title="1">{
                address, err := mail.ParseAddress(addresses[i])
                if err != nil </span><span class="cov0" title="0">{
                        email.Error = errors.New("Mail Error: " + err.Error() + "; Header: [" + header + "] Address: [" + addresses[i] + "]")
                        return email
                }</span>

                // check for more than one address
                <span class="cov8" title="1">switch </span>{
                case header == "From" &amp;&amp; len(email.from) &gt; 0:<span class="cov0" title="0">
                        fallthrough</span>
                case header == "Sender" &amp;&amp; len(email.sender) &gt; 0:<span class="cov0" title="0">
                        fallthrough</span>
                case header == "Reply-To" &amp;&amp; len(email.replyTo) &gt; 0:<span class="cov0" title="0">
                        fallthrough</span>
                case header == "Return-Path" &amp;&amp; len(email.returnPath) &gt; 0:<span class="cov0" title="0">
                        email.Error = errors.New("Mail Error: There can only be one \"" + header + "\" address; Header: [" + header + "] Address: [" + addresses[i] + "]")
                        return email</span>
                default:<span class="cov8" title="1"></span>
                        // other address types can have more than one address
                }

                // save the address
                <span class="cov8" title="1">switch header </span>{
                case "From":<span class="cov8" title="1">
                        email.from = address.Address</span>
                case "Sender":<span class="cov8" title="1">
                        email.sender = address.Address</span>
                case "Reply-To":<span class="cov8" title="1">
                        email.replyTo = address.Address</span>
                case "Return-Path":<span class="cov8" title="1">
                        email.returnPath = address.Address</span>
                default:<span class="cov8" title="1">
                        // check that the address was added to the recipients list
                        email.recipients, err = addAddress(email.recipients, address.Address)
                        if err != nil </span><span class="cov0" title="0">{
                                email.Error = errors.New("Mail Error: " + err.Error() + "; Header: [" + header + "] Address: [" + addresses[i] + "]")
                                return email
                        }</span>
                }

                // make sure the from and sender addresses are different
                <span class="cov8" title="1">if email.from != "" &amp;&amp; email.sender != "" &amp;&amp; email.from == email.sender </span><span class="cov0" title="0">{
                        email.sender = ""
                        email.headers.Del("Sender")
                        email.Error = errors.New("Mail Error: From and Sender should not be set to the same address")
                        return email
                }</span>

                // add all addresses to the headers except for Bcc and Return-Path
                <span class="cov8" title="1">if header != "Bcc" &amp;&amp; header != "Return-Path" </span><span class="cov8" title="1">{
                        // add the address to the headers
                        email.headers.Add(header, address.String())
                }</span>
        }

        <span class="cov8" title="1">return email</span>
}

// addAddress adds an address to the address list if it hasn't already been added
func addAddress(addressList []string, address string) ([]string, error) <span class="cov8" title="1">{
        // loop through the address list to check for dups
        for _, a := range addressList </span><span class="cov8" title="1">{
                if address == a </span><span class="cov0" title="0">{
                        return addressList, errors.New("Mail Error: Address: [" + address + "] has already been added")
                }</span>
        }

        <span class="cov8" title="1">return append(addressList, address), nil</span>
}

type priority int

const (
        // PriorityHigh sets the email priority to High
        PriorityHigh priority = iota
        // PriorityLow sets the email priority to Low
        PriorityLow
)

var priorities = [...]string{"High", "Low"}

func (priority priority) String() string <span class="cov8" title="1">{
        return priorities[priority]
}</span>

// SetPriority sets the email message priority. Use with
// either "High" or "Low".
func (email *Email) SetPriority(priority priority) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">switch priority </span>{
        case PriorityHigh:<span class="cov8" title="1">
                email.AddHeaders(textproto.MIMEHeader{
                        "X-Priority":        {"1 (Highest)"},
                        "X-MSMail-Priority": {"High"},
                        "Importance":        {"High"},
                })</span>
        case PriorityLow:<span class="cov8" title="1">
                email.AddHeaders(textproto.MIMEHeader{
                        "X-Priority":        {"5 (Lowest)"},
                        "X-MSMail-Priority": {"Low"},
                        "Importance":        {"Low"},
                })</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov8" title="1">return email</span>
}

// SetDate sets the date header to the provided date/time.
// The format of the string should be YYYY-MM-DD HH:MM:SS Time Zone.
//
// Example: SetDate("2015-04-28 10:32:00 CDT")
func (email *Email) SetDate(dateTime string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">const dateFormat = "2006-01-02 15:04:05 MST"

        // Try to parse the provided date/time
        dt, err := time.Parse(dateFormat, dateTime)
        if err != nil </span><span class="cov0" title="0">{
                email.Error = errors.New("Mail Error: Setting date failed with: " + err.Error())
                return email
        }</span>

        <span class="cov8" title="1">email.headers.Set("Date", dt.Format(time.RFC1123Z))

        return email</span>
}

// SetSubject sets the subject of the email message.
func (email *Email) SetSubject(subject string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.AddHeader("Subject", subject)

        return email</span>
}

// SetBody sets the body of the email message.
func (email *Email) SetBody(contentType, body string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.parts = []part{
                {
                        contentType: contentType,
                        body:        bytes.NewBufferString(body),
                },
        }

        return email</span>
}

// AddHeader adds the given "header" with the passed "value".
func (email *Email) AddHeader(header string, values ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        // check that there is actually a value
        <span class="cov8" title="1">if len(values) &lt; 1 </span><span class="cov0" title="0">{
                email.Error = errors.New("Mail Error: no value provided; Header: [" + header + "]")
                return email
        }</span>

        <span class="cov8" title="1">switch header </span>{
        case "Sender":<span class="cov0" title="0">
                fallthrough</span>
        case "From":<span class="cov0" title="0">
                fallthrough</span>
        case "To":<span class="cov0" title="0">
                fallthrough</span>
        case "Bcc":<span class="cov0" title="0">
                fallthrough</span>
        case "Cc":<span class="cov0" title="0">
                fallthrough</span>
        case "Reply-To":<span class="cov0" title="0">
                fallthrough</span>
        case "Return-Path":<span class="cov0" title="0">
                email.AddAddresses(header, values...)</span>
        case "Date":<span class="cov0" title="0">
                if len(values) &gt; 1 </span><span class="cov0" title="0">{
                        email.Error = errors.New("Mail Error: To many dates provided")
                        return email
                }</span>
                <span class="cov0" title="0">email.SetDate(values[0])</span>
        default:<span class="cov8" title="1">
                email.headers[header] = values</span>
        }

        <span class="cov8" title="1">return email</span>
}

// AddHeaders is used to add multiple headers at once
func (email *Email) AddHeaders(headers textproto.MIMEHeader) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">for header, values := range headers </span><span class="cov8" title="1">{
                email.AddHeader(header, values...)
        }</span>

        <span class="cov8" title="1">return email</span>
}

// AddAlternative allows you to add alternative parts to the body
// of the email message. This is most commonly used to add an
// html version in addition to a plain text version that was
// already added with SetBody.
func (email *Email) AddAlternative(contentType, body string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">email.parts = append(email.parts,
                part{
                        contentType: contentType,
                        body:        bytes.NewBufferString(body),
                },
        )

        return email</span>
}

// AddAttachment allows you to add an attachment to the email message.
// You can optionally provide a different name for the file.
func (email *Email) AddAttachment(file string, name ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 1 </span><span class="cov0" title="0">{
                email.Error = errors.New("Mail Error: Attach can only have a file and an optional name")
                return email
        }</span>

        <span class="cov8" title="1">email.Error = email.attach(file, false, name...)

        return email</span>
}

// AddAttachmentBase64 allows you to add an attachment in base64 to the email message.
// You need provide a name for the file.
func (email *Email) AddAttachmentBase64(b64File string, name string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">if len(name) &lt; 1 || len(b64File) &lt; 1 </span><span class="cov0" title="0">{
                email.Error = errors.New("Mail Error: Attach Base64 need have a base64 string and name")
                return email
        }</span>

        <span class="cov8" title="1">email.Error = email.attachB64(b64File, name)

        return email</span>
}

// AddInline allows you to add an inline attachment to the email message.
// You can optionally provide a different name for the file.
func (email *Email) AddInline(file string, name ...string) *Email <span class="cov8" title="1">{
        if email.Error != nil </span><span class="cov0" title="0">{
                return email
        }</span>

        <span class="cov8" title="1">if len(name) &gt; 1 </span><span class="cov0" title="0">{
                email.Error = errors.New("Mail Error: Inline can only have a file and an optional name")
                return email
        }</span>

        <span class="cov8" title="1">email.Error = email.attach(file, true, name...)

        return email</span>
}

// attach does the low level attaching of the files
func (email *Email) attach(f string, inline bool, name ...string) error <span class="cov8" title="1">{
        // Get the file data
        data, err := ioutil.ReadFile(f)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Mail Error: Failed to add file with following error: " + err.Error())
        }</span>

        // get the file mime type
        <span class="cov8" title="1">mimeType := mime.TypeByExtension(filepath.Ext(f))
        if mimeType == "" </span><span class="cov0" title="0">{
                mimeType = "application/octet-stream"
        }</span>

        // get the filename
        <span class="cov8" title="1">_, filename := filepath.Split(f)

        // if an alternative filename was provided, use that instead
        if len(name) == 1 </span><span class="cov0" title="0">{
                filename = name[0]
        }</span>

        <span class="cov8" title="1">if inline </span><span class="cov8" title="1">{
                email.inlines = append(email.inlines, &amp;file{
                        filename: filename,
                        mimeType: mimeType,
                        data:     data,
                })
        }</span> else<span class="cov8" title="1"> {
                email.attachments = append(email.attachments, &amp;file{
                        filename: filename,
                        mimeType: mimeType,
                        data:     data,
                })
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// attachB64 does the low level attaching of the files but decoding base64 instad have a filepath
func (email *Email) attachB64(b64File string, name string) error <span class="cov8" title="1">{

        // decode the string
        dec, err := base64.StdEncoding.DecodeString(b64File)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("Mail Error: Failed to decode base64 attachment with following error: " + err.Error())
        }</span>

        // get the file mime type
        <span class="cov8" title="1">mimeType := mime.TypeByExtension(name)
        if mimeType == "" </span><span class="cov8" title="1">{
                mimeType = "application/octet-stream"
        }</span>

        <span class="cov8" title="1">email.attachments = append(email.attachments, &amp;file{
                filename: name,
                mimeType: mimeType,
                data:     dec,
        })

        return nil</span>
}

// getFrom returns the sender of the email, if any
func (email *Email) getFrom() string <span class="cov8" title="1">{
        from := email.returnPath
        if from == "" </span><span class="cov8" title="1">{
                from = email.sender
                if from == "" </span><span class="cov8" title="1">{
                        from = email.from
                        if from == "" </span><span class="cov0" title="0">{
                                from = email.replyTo
                        }</span>
                }
        }

        <span class="cov8" title="1">return from</span>
}

func (email *Email) hasMixedPart() bool <span class="cov8" title="1">{
        return (len(email.parts) &gt; 0 &amp;&amp; len(email.attachments) &gt; 0) || len(email.attachments) &gt; 1
}</span>

func (email *Email) hasRelatedPart() bool <span class="cov8" title="1">{
        return (len(email.parts) &gt; 0 &amp;&amp; len(email.inlines) &gt; 0) || len(email.inlines) &gt; 1
}</span>

func (email *Email) hasAlternativePart() bool <span class="cov8" title="1">{
        return len(email.parts) &gt; 1
}</span>

// GetMessage builds and returns the email message
func (email *Email) GetMessage() string <span class="cov8" title="1">{
        msg := newMessage(email)

        if email.hasMixedPart() </span><span class="cov8" title="1">{
                msg.openMultipart("mixed")
        }</span>

        <span class="cov8" title="1">if email.hasRelatedPart() </span><span class="cov8" title="1">{
                msg.openMultipart("related")
        }</span>

        <span class="cov8" title="1">if email.hasAlternativePart() </span><span class="cov8" title="1">{
                msg.openMultipart("alternative")
        }</span>

        <span class="cov8" title="1">for _, part := range email.parts </span><span class="cov8" title="1">{
                msg.addBody(part.contentType, part.body.Bytes())
        }</span>

        <span class="cov8" title="1">if email.hasAlternativePart() </span><span class="cov8" title="1">{
                msg.closeMultipart()
        }</span>

        <span class="cov8" title="1">msg.addFiles(email.inlines, true)
        if email.hasRelatedPart() </span><span class="cov8" title="1">{
                msg.closeMultipart()
        }</span>

        <span class="cov8" title="1">msg.addFiles(email.attachments, false)
        if email.hasMixedPart() </span><span class="cov8" title="1">{
                msg.closeMultipart()
        }</span>

        <span class="cov8" title="1">return msg.getHeaders() + msg.body.String()</span>
}

// Send sends the composed email
func (email *Email) Send(smtpClient *SMTPClient) error <span class="cov8" title="1">{

        if email.Error != nil </span><span class="cov0" title="0">{
                return email.Error
        }</span>

        <span class="cov8" title="1">if len(email.recipients) &lt; 1 </span><span class="cov0" title="0">{
                return errors.New("Mail Error: No recipient specified")
        }</span>

        <span class="cov8" title="1">msg := email.GetMessage()

        return send(email.from, email.recipients, msg, smtpClient)</span>

}

// dial connects to the smtp server with the request encryption type
func dial(host string, port string, encryption encryption, config *tls.Config) (*Client, error) <span class="cov8" title="1">{
        var conn net.Conn
        var err error

        address := host + ":" + port

        // do the actual dial
        switch encryption </span>{
        case EncryptionSSL:<span class="cov0" title="0">
                conn, err = tls.Dial("tcp", address, config)</span>
        default:<span class="cov8" title="1">
                conn, err = net.Dial("tcp", address)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Mail Error on dailing with encryption type " + encryption.String() + ": " + err.Error())
        }</span>

        <span class="cov8" title="1">c, err := NewClient(conn, host)

        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Mail Error on smtp dial: " + err.Error())
        }</span>

        <span class="cov8" title="1">return c, err</span>
}

// smtpConnect connects to the smtp server and starts TLS and passes auth
// if necessary
func smtpConnect(host string, port string, auth Auth, encryption encryption, config *tls.Config) (*Client, error) <span class="cov8" title="1">{
        // connect to the mail server
        c, err := dial(host, port, encryption, config)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // send Hello
        <span class="cov8" title="1">if err = c.Hello("localhost"); err != nil </span><span class="cov0" title="0">{
                c.Close()
                return nil, errors.New("Mail Error on Hello: " + err.Error())
        }</span>

        // start TLS if necessary
        <span class="cov8" title="1">if encryption == EncryptionTLS </span><span class="cov0" title="0">{
                if ok, _ := c.Extension("STARTTLS"); ok </span><span class="cov0" title="0">{
                        if config.ServerName == "" </span><span class="cov0" title="0">{
                                config = &amp;tls.Config{ServerName: host}
                        }</span>

                        <span class="cov0" title="0">if err = c.StartTLS(config); err != nil </span><span class="cov0" title="0">{
                                c.Close()
                                return nil, errors.New("Mail Error on Start TLS: " + err.Error())
                        }</span>
                }
        }

        // pass the authentication if necessary
        <span class="cov8" title="1">if auth != nil </span><span class="cov8" title="1">{
                if ok, _ := c.Extension("AUTH"); ok </span><span class="cov8" title="1">{
                        if err = c.Auth(auth); err != nil </span><span class="cov0" title="0">{
                                c.Close()
                                return nil, errors.New("Mail Error on Auth: " + err.Error())
                        }</span>
                }
        }

        <span class="cov8" title="1">return c, nil</span>
}

//Connect returns the smtp client
func (server *SMTPServer) Connect() (*SMTPClient, error) <span class="cov8" title="1">{

        var auth Auth

        if server.Username != "" || server.Password != "" </span><span class="cov8" title="1">{
                auth = PlainAuth("", server.Username, server.Password, server.Host)
        }</span>

        <span class="cov8" title="1">var smtpConnectChannel chan error
        var c *Client
        var err error

        // if there is a ConnectTimeout, setup the channel and do the connect under a goroutine
        if server.ConnectTimeout != 0 </span><span class="cov8" title="1">{
                smtpConnectChannel = make(chan error, 2)
                go func() </span><span class="cov8" title="1">{
                        c, err = smtpConnect(server.Host, fmt.Sprintf("%d", server.Port), auth, server.Encryption, new(tls.Config))
                        // send the result
                        smtpConnectChannel &lt;- err
                }</span>()
        }

        <span class="cov8" title="1">if server.ConnectTimeout == 0 </span><span class="cov0" title="0">{
                // no ConnectTimeout, just fire the connect
                c, err = smtpConnect(server.Host, fmt.Sprintf("%d", server.Port), auth, server.Encryption, new(tls.Config))
        }</span> else<span class="cov8" title="1"> {
                // get the connect result or timeout result, which ever happens first
                select </span>{
                case err = &lt;-smtpConnectChannel:<span class="cov8" title="1">
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New(err.Error())
                        }</span>
                case &lt;-time.After(server.ConnectTimeout):<span class="cov0" title="0">
                        return nil, errors.New("Mail Error: SMTP Connection timed out")</span>
                }
        }

        <span class="cov8" title="1">return &amp;SMTPClient{
                Client:      c,
                KeepAlive:   server.KeepAlive,
                SendTimeout: server.SendTimeout,
        }, nil</span>
}

// send does the low level sending of the email
func send(from string, to []string, msg string, smtpClient *SMTPClient) error <span class="cov8" title="1">{

        //Check if client struct is not nil
        if smtpClient != nil </span><span class="cov8" title="1">{

                //Check if client is not nil
                if smtpClient.Client != nil </span><span class="cov8" title="1">{
                        var smtpSendChannel chan error

                        smtpSendChannel = make(chan error, 1)

                        go func(c *Client) </span><span class="cov8" title="1">{
                                // Set the sender
                                if err := c.Mail(from); err != nil </span><span class="cov0" title="0">{
                                        smtpSendChannel &lt;- err
                                        return
                                }</span>

                                // Set the recipients
                                <span class="cov8" title="1">for _, address := range to </span><span class="cov8" title="1">{
                                        if err := c.Rcpt(address); err != nil </span><span class="cov0" title="0">{
                                                smtpSendChannel &lt;- err
                                                return
                                        }</span>
                                }

                                // Send the data command
                                <span class="cov8" title="1">w, err := c.Data()
                                if err != nil </span><span class="cov0" title="0">{
                                        smtpSendChannel &lt;- err
                                        return
                                }</span>

                                // write the message
                                <span class="cov8" title="1">_, err = fmt.Fprint(w, msg)
                                if err != nil </span><span class="cov0" title="0">{
                                        smtpSendChannel &lt;- err
                                        return
                                }</span>

                                <span class="cov8" title="1">err = w.Close()
                                if err != nil </span><span class="cov0" title="0">{
                                        smtpSendChannel &lt;- err
                                        return
                                }</span>

                                <span class="cov8" title="1">smtpSendChannel &lt;- err</span>

                        }(smtpClient.Client)

                        <span class="cov8" title="1">select </span>{
                        case sendError := &lt;-smtpSendChannel:<span class="cov8" title="1">
                                checkKeepAlive(smtpClient)
                                return sendError</span>
                        case &lt;-time.After(smtpClient.SendTimeout):<span class="cov0" title="0">
                                checkKeepAlive(smtpClient)
                                return errors.New("Mail Error: SMTP Send timed out")</span>
                        }
                }
        }

        <span class="cov0" title="0">return errors.New("Mail Error: No SMTP Client Provided")</span>
}

//check if keepAlive for close or reset
func checkKeepAlive(smtpClient *SMTPClient) <span class="cov8" title="1">{
        if smtpClient.KeepAlive </span><span class="cov8" title="1">{
                smtpClient.Client.Reset()
        }</span> else<span class="cov8" title="1"> {
                smtpClient.Client.Quit()
                smtpClient.Client.Close()
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package mail

import (
        "bytes"
        "encoding/base64"
        "io"
        "mime/multipart"
        "mime/quotedprintable"
        "net/textproto"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/joegrasse/mime/header"
)

type message struct {
        headers  textproto.MIMEHeader
        body     *bytes.Buffer
        writers  []*multipart.Writer
        parts    uint8
        cids     map[string]string
        charset  string
        encoding encoding
}

func newMessage(email *Email) *message <span class="cov8" title="1">{
        return &amp;message{
                headers:  email.headers,
                body:     new(bytes.Buffer),
                cids:     make(map[string]string),
                charset:  email.Charset,
                encoding: email.Encoding}
}</span>

func encodeHeader(text string, charset string, usedChars int) string <span class="cov8" title="1">{
        // create buffer
        buf := new(bytes.Buffer)

        // encode
        encoder := header.NewEncoder(buf, charset, usedChars)
        encoder.Encode([]byte(text))

        return buf.String()

        /*
                        switch encoding {
                        case EncodingBase64:
                                return mime.BEncoding.Encode(charset, text)
                        default:
                                return mime.QEncoding.Encode(charset, text)
                }
        */
}</span>

// getHeaders returns the message headers
func (msg *message) getHeaders() (headers string) <span class="cov8" title="1">{
        // if the date header isn't set, set it
        if date := msg.headers.Get("Date"); date == "" </span><span class="cov8" title="1">{
                msg.headers.Set("Date", time.Now().Format(time.RFC1123Z))
        }</span>

        // encode and combine the headers
        <span class="cov8" title="1">for header, values := range msg.headers </span><span class="cov8" title="1">{
                headers += header + ": " + encodeHeader(strings.Join(values, ", "), msg.charset, len(header)+2) + "\r\n"
        }</span>

        <span class="cov8" title="1">headers = headers + "\r\n"

        return</span>
}

// getCID gets the generated CID for the provided text
func (msg *message) getCID(text string) (cid string) <span class="cov8" title="1">{
        // set the date format to use
        const dateFormat = "20060102.150405"

        // get the cid if we have one
        cid, exists := msg.cids[text]
        if !exists </span><span class="cov8" title="1">{
                // generate a new cid
                cid = time.Now().Format(dateFormat) + "." + strconv.Itoa(len(msg.cids)+1) + "@mail.0"
                // save it
                msg.cids[text] = cid
        }</span>

        <span class="cov8" title="1">return</span>
}

// replaceCIDs replaces the CIDs found in a text string
// with generated ones
func (msg *message) replaceCIDs(text string) string <span class="cov8" title="1">{
        // regular expression to find cids
        re := regexp.MustCompile(`(src|href)="cid:(.*?)"`)
        // replace all of the found cids with generated ones
        for _, matches := range re.FindAllStringSubmatch(text, -1) </span><span class="cov8" title="1">{
                cid := msg.getCID(matches[2])
                text = strings.Replace(text, "cid:"+matches[2], "cid:"+cid, -1)
        }</span>

        <span class="cov8" title="1">return text</span>
}

// openMultipart creates a new part of a multipart message
func (msg *message) openMultipart(multipartType string) <span class="cov8" title="1">{
        // create a new multipart writer
        msg.writers = append(msg.writers, multipart.NewWriter(msg.body))
        // create the boundary
        contentType := "multipart/" + multipartType + ";\n \tboundary=" + msg.writers[msg.parts].Boundary()

        // if no existing parts, add header to main header group
        if msg.parts == 0 </span><span class="cov8" title="1">{
                msg.headers.Set("Content-Type", contentType)
        }</span> else<span class="cov8" title="1"> { // add header to multipart section
                header := make(textproto.MIMEHeader)
                header.Set("Content-Type", contentType)
                msg.writers[msg.parts-1].CreatePart(header)
        }</span>

        <span class="cov8" title="1">msg.parts++</span>
}

// closeMultipart closes a part of a multipart message
func (msg *message) closeMultipart() <span class="cov8" title="1">{
        if msg.parts &gt; 0 </span><span class="cov8" title="1">{
                msg.writers[msg.parts-1].Close()
                msg.parts--
        }</span>
}

// base64Encode base64 encodes the provided text with line wrapping
func base64Encode(text []byte) []byte <span class="cov8" title="1">{
        // create buffer
        buf := new(bytes.Buffer)

        // create base64 encoder that linewraps
        encoder := base64.NewEncoder(base64.StdEncoding, &amp;base64LineWrap{writer: buf})

        // write the encoded text to buf
        encoder.Write(text)
        encoder.Close()

        return buf.Bytes()
}</span>

// qpEncode uses the quoted-printable encoding to encode the provided text
func qpEncode(text []byte) []byte <span class="cov8" title="1">{
        // create buffer
        buf := new(bytes.Buffer)

        encoder := quotedprintable.NewWriter(buf)

        encoder.Write(text)
        encoder.Close()

        return buf.Bytes()
}</span>

const maxLineChars = 76

type base64LineWrap struct {
        writer       io.Writer
        numLineChars int
}

func (e *base64LineWrap) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        n = 0
        // while we have more chars than are allowed
        for len(p)+e.numLineChars &gt; maxLineChars </span><span class="cov8" title="1">{
                numCharsToWrite := maxLineChars - e.numLineChars
                // write the chars we can
                e.writer.Write(p[:numCharsToWrite])
                // write a line break
                e.writer.Write([]byte("\r\n"))
                // reset the line count
                e.numLineChars = 0
                // remove the chars that have been written
                p = p[numCharsToWrite:]
                // set the num of chars written
                n += numCharsToWrite
        }</span>

        // write what is left
        <span class="cov8" title="1">e.writer.Write(p)
        e.numLineChars += len(p)
        n += len(p)

        return</span>
}

func (msg *message) write(header textproto.MIMEHeader, body []byte, encoding encoding) <span class="cov8" title="1">{
        msg.writeHeader(header)
        msg.writeBody(body, encoding)
}</span>

func (msg *message) writeHeader(headers textproto.MIMEHeader) <span class="cov8" title="1">{
        // if there are no parts add header to main headers
        if msg.parts == 0 </span><span class="cov8" title="1">{
                for header, value := range headers </span><span class="cov8" title="1">{
                        msg.headers[header] = value
                }</span>
        } else<span class="cov8" title="1"> { // add header to multipart section
                msg.writers[msg.parts-1].CreatePart(headers)
        }</span>
}

func (msg *message) writeBody(body []byte, encoding encoding) <span class="cov8" title="1">{
        // encode and write the body
        switch encoding </span>{
        case EncodingQuotedPrintable:<span class="cov8" title="1">
                msg.body.Write(qpEncode(body))</span>
        case EncodingBase64:<span class="cov8" title="1">
                msg.body.Write(base64Encode(body))</span>
        default:<span class="cov0" title="0">
                msg.body.Write(body)</span>
        }
}

func (msg *message) addBody(contentType string, body []byte) <span class="cov8" title="1">{
        body = []byte(msg.replaceCIDs(string(body)))

        header := make(textproto.MIMEHeader)
        header.Set("Content-Type", contentType+"; charset="+msg.charset)
        header.Set("Content-Transfer-Encoding", msg.encoding.String())
        msg.write(header, body, msg.encoding)
}</span>

var quoteEscaper = strings.NewReplacer("\\", "\\\\", `"`, "\\\"")

func escapeQuotes(s string) string <span class="cov8" title="1">{
        return quoteEscaper.Replace(s)
}</span>

func (msg *message) addFiles(files []*file, inline bool) <span class="cov8" title="1">{
        encoding := EncodingBase64
        for _, file := range files </span><span class="cov8" title="1">{
                header := make(textproto.MIMEHeader)
                header.Set("Content-Type", file.mimeType+";\n \tname=\""+encodeHeader(escapeQuotes(file.filename), msg.charset, 6)+`"`)
                header.Set("Content-Transfer-Encoding", encoding.String())
                if inline </span><span class="cov8" title="1">{
                        header.Set("Content-Disposition", "inline;\n \tfilename=\""+encodeHeader(escapeQuotes(file.filename), msg.charset, 10)+`"`)
                        header.Set("Content-ID", "&lt;"+msg.getCID(file.filename)+"&gt;")
                }</span> else<span class="cov8" title="1"> {
                        header.Set("Content-Disposition", "attachment;\n \tfilename=\""+encodeHeader(escapeQuotes(file.filename), msg.charset, 10)+`"`)
                }</span>

                <span class="cov8" title="1">msg.write(header, file.data, encoding)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in https://raw.githubusercontent.com/golang/go/master/LICENSE

// Package mail implements the Simple Mail Transfer Protocol as defined in RFC 5321.
// It also implements the following extensions:
//        8BITMIME  RFC 1652
//        AUTH      RFC 2554
//        STARTTLS  RFC 3207
// Additional extensions may be handled by clients.
//
// The smtp package is frozen and is not accepting new features.
// Some external packages provide more functionality. See:
//
//   https://godoc.org/?q=smtp
package mail

import (
        "crypto/tls"
        "encoding/base64"
        "errors"
        "fmt"
        "io"
        "net"
        "net/textproto"
        "strings"
)

// A Client represents a client connection to an SMTP server.
type Client struct {
        // Text is the textproto.Conn used by the Client. It is exported to allow for
        // clients to add extensions.
        Text *textproto.Conn
        // keep a reference to the connection so it can be used to create a TLS
        // connection later
        conn net.Conn
        // whether the Client is using TLS
        tls        bool
        serverName string
        // map of supported extensions
        ext map[string]string
        // supported auth mechanisms
        auth       []string
        localName  string // the name to use in HELO/EHLO
        didHello   bool   // whether we've said HELO/EHLO
        helloError error  // the error from the hello
}

// NewClient returns a new Client using an existing connection and host as a
// server name to be used when authenticating.
func NewClient(conn net.Conn, host string) (*Client, error) <span class="cov8" title="1">{
        text := textproto.NewConn(conn)
        _, _, err := text.ReadResponse(220)
        if err != nil </span><span class="cov0" title="0">{
                text.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">c := &amp;Client{Text: text, conn: conn, serverName: host, localName: "localhost"}
        _, c.tls = conn.(*tls.Conn)
        return c, nil</span>
}

// Close closes the connection.
func (c *Client) Close() error <span class="cov8" title="1">{
        return c.Text.Close()
}</span>

// hello runs a hello exchange if needed.
func (c *Client) hello() error <span class="cov8" title="1">{
        if !c.didHello </span><span class="cov8" title="1">{
                c.didHello = true
                err := c.ehlo()
                if err != nil </span><span class="cov0" title="0">{
                        c.helloError = c.helo()
                }</span>
        }
        <span class="cov8" title="1">return c.helloError</span>
}

// Hello sends a HELO or EHLO to the server as the given host name.
// Calling this method is only necessary if the client needs control
// over the host name used. The client will introduce itself as "localhost"
// automatically otherwise. If Hello is called, it must be called before
// any of the other methods.
func (c *Client) Hello(localName string) error <span class="cov8" title="1">{
        if err := validateLine(localName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if c.didHello </span><span class="cov0" title="0">{
                return errors.New("smtp: Hello called after other methods")
        }</span>
        <span class="cov8" title="1">c.localName = localName
        return c.hello()</span>
}

// cmd is a convenience function that sends a command and returns the response
func (c *Client) cmd(expectCode int, format string, args ...interface{}) (int, string, error) <span class="cov8" title="1">{
        id, err := c.Text.Cmd(format, args...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, "", err
        }</span>
        <span class="cov8" title="1">c.Text.StartResponse(id)
        defer c.Text.EndResponse(id)
        code, msg, err := c.Text.ReadResponse(expectCode)
        return code, msg, err</span>
}

// helo sends the HELO greeting to the server. It should be used only when the
// server does not support ehlo.
func (c *Client) helo() error <span class="cov8" title="1">{
        c.ext = nil
        _, _, err := c.cmd(250, "HELO %s", c.localName)
        return err
}</span>

// ehlo sends the EHLO (extended hello) greeting to the server. It
// should be the preferred greeting for servers that support it.
func (c *Client) ehlo() error <span class="cov8" title="1">{
        _, msg, err := c.cmd(250, "EHLO %s", c.localName)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">ext := make(map[string]string)
        extList := strings.Split(msg, "\n")
        if len(extList) &gt; 1 </span><span class="cov8" title="1">{
                extList = extList[1:]
                for _, line := range extList </span><span class="cov8" title="1">{
                        args := strings.SplitN(line, " ", 2)
                        if len(args) &gt; 1 </span><span class="cov8" title="1">{
                                ext[args[0]] = args[1]
                        }</span> else<span class="cov8" title="1"> {
                                ext[args[0]] = ""
                        }</span>
                }
        }
        <span class="cov8" title="1">if mechs, ok := ext["AUTH"]; ok </span><span class="cov8" title="1">{
                c.auth = strings.Split(mechs, " ")
        }</span>
        <span class="cov8" title="1">c.ext = ext
        return err</span>
}

// StartTLS sends the STARTTLS command and encrypts all further communication.
// Only servers that advertise the STARTTLS extension support this function.
func (c *Client) StartTLS(config *tls.Config) error <span class="cov0" title="0">{
        if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">_, _, err := c.cmd(220, "STARTTLS")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">c.conn = tls.Client(c.conn, config)
        c.Text = textproto.NewConn(c.conn)
        c.tls = true
        return c.ehlo()</span>
}

// Auth authenticates a client using the provided authentication mechanism.
// A failed authentication closes the connection.
// Only servers that advertise the AUTH extension support this function.
func (c *Client) Auth(a Auth) error <span class="cov8" title="1">{
        if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">encoding := base64.StdEncoding
        mech, resp, err := a.Start(&amp;ServerInfo{c.serverName, c.tls, c.auth})
        if err != nil </span><span class="cov0" title="0">{
                c.Quit()
                return err
        }</span>
        <span class="cov8" title="1">resp64 := make([]byte, encoding.EncodedLen(len(resp)))
        encoding.Encode(resp64, resp)
        code, msg64, err := c.cmd(0, strings.TrimSpace(fmt.Sprintf("AUTH %s %s", mech, resp64)))
        for err == nil </span><span class="cov8" title="1">{
                var msg []byte
                switch code </span>{
                case 334:<span class="cov0" title="0">
                        msg, err = encoding.DecodeString(msg64)</span>
                case 235:<span class="cov8" title="1">
                        // the last message isn't base64 because it isn't a challenge
                        msg = []byte(msg64)</span>
                default:<span class="cov0" title="0">
                        err = &amp;textproto.Error{Code: code, Msg: msg64}</span>
                }
                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                        resp, err = a.Next(msg, code == 334)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        // abort the AUTH
                        c.cmd(501, "*")
                        c.Quit()
                        break</span>
                }
                <span class="cov8" title="1">if resp == nil </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov0" title="0">resp64 = make([]byte, encoding.EncodedLen(len(resp)))
                encoding.Encode(resp64, resp)
                code, msg64, err = c.cmd(0, string(resp64))</span>
        }
        <span class="cov8" title="1">return err</span>
}

// Mail issues a MAIL command to the server using the provided email address.
// If the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME
// parameter.
// This initiates a mail transaction and is followed by one or more Rcpt calls.
func (c *Client) Mail(from string) error <span class="cov8" title="1">{
        if err := validateLine(from); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">cmdStr := "MAIL FROM:&lt;%s&gt;"
        if c.ext != nil </span><span class="cov8" title="1">{
                if _, ok := c.ext["8BITMIME"]; ok </span><span class="cov0" title="0">{
                        cmdStr += " BODY=8BITMIME"
                }</span>
        }
        <span class="cov8" title="1">_, _, err := c.cmd(250, cmdStr, from)
        return err</span>
}

// Rcpt issues a RCPT command to the server using the provided email address.
// A call to Rcpt must be preceded by a call to Mail and may be followed by
// a Data call or another Rcpt call.
func (c *Client) Rcpt(to string) error <span class="cov8" title="1">{
        if err := validateLine(to); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, _, err := c.cmd(250, "RCPT TO:&lt;%s&gt;", to)
        return err</span>
}

type dataCloser struct {
        c *Client
        io.WriteCloser
}

func (d *dataCloser) Close() error <span class="cov8" title="1">{
        d.WriteCloser.Close()
        _, _, err := d.c.Text.ReadResponse(250)
        return err
}</span>

// Data issues a DATA command to the server and returns a writer that
// can be used to write the mail headers and body. The caller should
// close the writer before calling any more methods on c. A call to
// Data must be preceded by one or more calls to Rcpt.
func (c *Client) Data() (io.WriteCloser, error) <span class="cov8" title="1">{
        _, _, err := c.cmd(354, "DATA")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;dataCloser{c, c.Text.DotWriter()}, nil</span>
}

// Extension reports whether an extension is support by the server.
// The extension name is case-insensitive. If the extension is supported,
// Extension also returns a string that contains any parameters the
// server specifies for the extension.
func (c *Client) Extension(ext string) (bool, string) <span class="cov8" title="1">{
        if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return false, ""
        }</span>
        <span class="cov8" title="1">if c.ext == nil </span><span class="cov0" title="0">{
                return false, ""
        }</span>
        <span class="cov8" title="1">ext = strings.ToUpper(ext)
        param, ok := c.ext[ext]
        return ok, param</span>
}

// Reset sends the RSET command to the server, aborting the current mail
// transaction.
func (c *Client) Reset() error <span class="cov8" title="1">{
        if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, _, err := c.cmd(250, "RSET")
        return err</span>
}

// Noop sends the NOOP command to the server. It does nothing but check
// that the connection to the server is okay.
func (c *Client) Noop() error <span class="cov8" title="1">{
        if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, _, err := c.cmd(250, "NOOP")
        return err</span>
}

// Quit sends the QUIT command and closes the connection to the server.
func (c *Client) Quit() error <span class="cov8" title="1">{
        if err := c.hello(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">_, _, err := c.cmd(221, "QUIT")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return c.Text.Close()</span>
}

// validateLine checks to see if a line has CR or LF as per RFC 5321
func validateLine(line string) error <span class="cov8" title="1">{
        if strings.ContainsAny(line, "\n\r") </span><span class="cov0" title="0">{
                return errors.New("smtp: A line must not contain CR or LF")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
